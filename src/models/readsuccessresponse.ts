/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  MetaFiles,
  MetaFiles$inboundSchema,
  MetaFiles$Outbound,
  MetaFiles$outboundSchema,
} from "./metafiles.js";
import {
  Metrics,
  Metrics$inboundSchema,
  Metrics$Outbound,
  Metrics$outboundSchema,
} from "./metrics.js";
import {
  PageMetadata,
  PageMetadata$inboundSchema,
  PageMetadata$Outbound,
  PageMetadata$outboundSchema,
} from "./pagemetadata.js";

export type ReadSuccessResponse = {
  success: boolean;
  /**
   * The flag to indicate whether the response was cached. This is always false since we are not caching the response for privacy reasons. You need to cache it yourself in your application.
   */
  cached?: boolean | undefined;
  targetUrl: string;
  title: string;
  description: string;
  metadata?: PageMetadata | undefined;
  cleanedHtml?: string | undefined;
  metaFiles?: MetaFiles | undefined;
  /**
   * Markdown content of the page.
   */
  markdown?: string | undefined;
  /**
   * Raw HTML content of the page.
   */
  rawHtml?: string | undefined;
  /**
   * Metrics for the read operation.
   */
  metrics?: Metrics | undefined;
};

/** @internal */
export const ReadSuccessResponse$inboundSchema: z.ZodType<
  ReadSuccessResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  success: z.boolean(),
  cached: z.boolean().default(false),
  targetUrl: z.string(),
  title: z.string(),
  description: z.string(),
  metadata: PageMetadata$inboundSchema.optional(),
  cleanedHtml: z.string().optional(),
  metaFiles: MetaFiles$inboundSchema.optional(),
  markdown: z.string().optional(),
  rawHtml: z.string().optional(),
  metrics: Metrics$inboundSchema.optional(),
});

/** @internal */
export type ReadSuccessResponse$Outbound = {
  success: boolean;
  cached: boolean;
  targetUrl: string;
  title: string;
  description: string;
  metadata?: PageMetadata$Outbound | undefined;
  cleanedHtml?: string | undefined;
  metaFiles?: MetaFiles$Outbound | undefined;
  markdown?: string | undefined;
  rawHtml?: string | undefined;
  metrics?: Metrics$Outbound | undefined;
};

/** @internal */
export const ReadSuccessResponse$outboundSchema: z.ZodType<
  ReadSuccessResponse$Outbound,
  z.ZodTypeDef,
  ReadSuccessResponse
> = z.object({
  success: z.boolean(),
  cached: z.boolean().default(false),
  targetUrl: z.string(),
  title: z.string(),
  description: z.string(),
  metadata: PageMetadata$outboundSchema.optional(),
  cleanedHtml: z.string().optional(),
  metaFiles: MetaFiles$outboundSchema.optional(),
  markdown: z.string().optional(),
  rawHtml: z.string().optional(),
  metrics: Metrics$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ReadSuccessResponse$ {
  /** @deprecated use `ReadSuccessResponse$inboundSchema` instead. */
  export const inboundSchema = ReadSuccessResponse$inboundSchema;
  /** @deprecated use `ReadSuccessResponse$outboundSchema` instead. */
  export const outboundSchema = ReadSuccessResponse$outboundSchema;
  /** @deprecated use `ReadSuccessResponse$Outbound` instead. */
  export type Outbound = ReadSuccessResponse$Outbound;
}

export function readSuccessResponseToJSON(
  readSuccessResponse: ReadSuccessResponse,
): string {
  return JSON.stringify(
    ReadSuccessResponse$outboundSchema.parse(readSuccessResponse),
  );
}

export function readSuccessResponseFromJSON(
  jsonString: string,
): SafeParseResult<ReadSuccessResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReadSuccessResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReadSuccessResponse' from JSON`,
  );
}
